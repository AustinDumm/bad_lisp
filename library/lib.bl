(let* ((Y (lambda (f) 
            ((lambda (x) (x x))
             (lambda (x) (f (lambda n (apply (x x) n)))))))
       (reverse (lambda (list)
                    ((Y (lambda (f)
                            (lambda (list running)
                                    (if (nil? list)
                                        running
                                        (f (rest list) (cons (first list) running)))))) list ())))
       (factorial (lambda (n)
                    ((Y (lambda (f)
                        (lambda (n r)
                            (if (= n 1)
                                r
                                (f (- n 1) (* n r)))))) n 1)))
       (count (lambda (data)
                ((Y (lambda (f)
                        (lambda (data running)
                            (if (nil? data)
                                running
                                (f (rest data) (+ 1 running)))))) data 0)))
       (map (lambda (func values)
                ((Y (lambda (f)
                        (lambda (func values running)
                            (if (nil? values)
                                (reverse running)
                                (f func (rest values) (cons (func (first values)) running)))))) func values ())))
       (reduce (Y (lambda (f)
                        (lambda (func values acc)
                            (if (nil? values)
                                acc
                                (f func (rest values) (func (first values) acc)))))))
       (filter (lambda (predicate values)
                        ((Y (lambda (f)
                                (lambda (predicate values running)
                                    (if (nil? values)
                                        (reverse running)
                                        (if (predicate (first values))
                                            (f predicate (rest values) (cons (first values) running))
                                            (f predicate (rest values) running)))))) predicate values ())))
       (range (lambda (first last step)
                            ((Y (lambda (f)
                                    (lambda (first last step running)
                                        (if (> (* first (sign step)) (* last (sign step)))
                                            (reverse running)
                                            (f (+ first step) last step (cons first running)))))) first last step ())))
       (all-satisfy (Y (lambda (f)
                            (lambda (predicate data)
                                (if (nil? data)
                                    #t
                                    (if (not (predicate (first data)))
                                        #f
                                        (f predicate (rest data))))))))
       (any-satisfy (lambda (data predicate)
                        (not (all-satisfy data (lambda (x) (not (predicate x)))))))
       (first-satisfying (Y (lambda (f)
                                (lambda (predicate data)
                                    (if (nil? data)
                                        ()
                                        (if (predicate (first data))
                                            (first data)
                                            (f predicate (rest data))))))))
       (zip (lambda (left right)
                ((Y (lambda (f)
                            (lambda (left right running)
                                (if (or (nil? left) (nil? right))
                                    (reverse running)
                                    (f (rest left) (rest right) (cons (list (first left) (first right)) running)))))) left right ())))
       (take (lambda (count list)
                ((Y (lambda (f)
                        (lambda (count list running)
                            (if (or (= count 0) (nil? list))
                                (reverse running)
                                (f (- count 1) (rest list) (cons (first list) running)))))) count list ())))
       (drop (Y (lambda (f)
                    (lambda (count list)
                        (if (or (= count 0) (nil? list))
                            list
                            (f (- count 1) (rest list)))))))
       (pick (Y (lambda (f)
                    (lambda (elt list)
                        (if (nil? list)
                            ()
                            (if (= elt 0)
                                (first list)
                                (f (- elt 1) (rest list))))))))
       (append (lambda (start end)
                    ((Y (lambda (f)
                            (lambda (start end)
                                (if (nil? start)
                                    end
                                    (f (rest start) (cons (first start) end)))))) (reverse start) end)))
       (enumerated (lambda (list)
                        (zip (range 0 (count list) 1) list)))
       (cond (macro (raw-list)
            (let ((inner-cond (macro (cond-list-sym)
                                     (let ((cond-list (eval cond-list-sym)))
                                        (let ((first-cond (first cond-list))
                                              (rest-cond (rest cond-list)))
                                              (let ((first-pred (first first-cond))
                                                    (first-result (first (rest first-cond))))
                                                    (if (eval first-pred)
                                                        (eval first-result)
                                                        (if (nil? rest-cond)
                                                            ()
                                                            (inner-cond rest-cond))))))))
                  (list-sym raw-list))
                  (inner-cond list-sym)))))
       `((Y ,Y)
         (reverse ,reverse)
         (count ,count)
         (factorial ,factorial)
         (map ,map)
         (reduce ,reduce)
         (filter ,filter)
         (range ,range)
         (all-satisfy ,all-satisfy)
         (any-satisfy ,any-satisfy)
         (first-satisfying ,first-satisfying)
         (zip ,zip)
         (take ,take)
         (drop ,drop)
         (pick ,pick)
         (append ,append)
         (enumerated ,enumerated)
         (cond ,cond)))
