(dyn-let (load "./library/gen.bl")
    (dyn-let (load "./library/lib.bl")
            (let* ((is-unquoted (lambda (elt)
                                    (and (and (list? elt) (= (first elt) 'unquote)) (and (list? (rest elt)) (nil? (rest (rest elt)))))))
                   (get-quoted-elt (lambda (elt)
                                    (first (rest elt))))
                   (structure-match (Y (lambda (f)
                                        (lambda (first-expr second-expr matched-pairs)
                                            (cond (((and (nil? first-expr) (nil? second-expr))
                                                        `(,#t ,matched-pairs))
                                                   ((or (nil? first-expr) (nil? second-expr))
                                                        `(,#f ()))
                                                   ((is-unquoted first-expr)
                                                        `(,#t ,(cons `(,(get-quoted-elt first-expr) ',second-expr) matched-pairs)))
                                                   ((and (list? first-expr) (list? second-expr))
                                                        (let ((first-elt (first first-expr))
                                                              (first-rest (rest first-expr))
                                                              (second-elt (first second-expr))
                                                              (second-rest (rest second-expr)))
                                                             (cond (((is-unquoted first-elt) 
                                                                        (f first-rest second-rest (cons `(,(get-quoted-elt first-elt) ',second-elt) matched-pairs)))
                                                                    ((and (list? first-elt) (list? second-elt))
                                                                        (let* ((elt-result (f first-elt second-elt matched-pairs))
                                                                               (elt-success (first elt-result))
                                                                               (elt-pairs (first (rest elt-result))))
                                                                            (if elt-success
                                                                                (f first-rest second-rest elt-pairs)
                                                                                `(,#f ()))))
                                                                    ((and (nil? first-rest) (nil? second-rest))
                                                                        `(,(= first-elt second-elt) ,matched-pairs))
                                                                    ((not (= first-elt second-elt))
                                                                        '(#f ()))
                                                                    (#t
                                                                        (f first-rest second-rest matched-pairs)))
                                                             )))
                                                   ((= first-expr second-expr)
                                                        `(,#t ,matched-pairs))
                                                   ((!= first-expr second-expr)
                                                        `(,#f ()))))))))
                   (match (Y (lambda (f)
                                   (lambda (value . options)
                                    (if (nil? options)
                                        ()
                                        (let* ((first-opt (first options))
                                               (rest-opt (rest options))
                                               (opt-structure (first first-opt))
                                               (opt-exe (first (rest first-opt)))
                                               (result (structure-match opt-structure value ()))
                                               (success (first result))
                                               (match-list (first (rest result))))
                                              (if success
                                                  (list match-list opt-exe)
                                                  (apply f (cons value rest-opt)))))))))
                   (match-mac (macro (value . arguments)
                                    (let ((result-pair (apply match (cons ,value arguments))))
                                        (if (nil? result-pair)
                                            ()
                                            (let ((match-list (pick 0 result-pair))
                                                  (opt-exe (pick 1 result-pair)))
                                                (dyn-let match-list ,opt-exe)))))))
                `((match ,match)
                  (match-mac ,match-mac))
            )
    )
)

