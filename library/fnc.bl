(let ((wrap (quote ((reverse (lambda (list)
                    (((lambda (x) (x x))
                     (lambda (reverse*)
                        (lambda (list running)
                                (if (nil? list)
                                    running
                                    ((reverse* reverse*) (rest list) (cons (first list) running)))))) list ())))))))
    (dyn-let wrap
        (cons (first wrap) 
            (quote
                ((map ((lambda (x) (x x))
                             (lambda (map*)
                                (lambda (values func)
                                    (if (nil? (rest values))
                                        (cons (func (first values)) ())
                                        (cons (func (first values)) ((map* map*) (rest values) func)))))))
                (reduce ((lambda (x) (x x))
                                (lambda (reduce*)
                                    (lambda (values acc func)
                                        (if (nil? (rest values))
                                            (func acc (first values))
                                            (func ((reduce* reduce*) (rest values) acc func) (first values)))))))
                (filter ((lambda (x) (x x))
                                (lambda (filter*)
                                    (lambda (values predicate)
                                        (if (nil? values)
                                            ()
                                            (if (predicate (first values))
                                                (cons (first values) ((filter* filter*) (rest values) predicate))
                                                ((filter* filter*) (rest values) predicate)))))))
                (range ((lambda (x) (x x))
                               (lambda (range*)
                                    (lambda (first last step)
                                        (if (> (* first (sign step)) (* last (sign step)))
                                            ()
                                            (cons first ((range* range*) (+ first step) last step)))))))
                (cond (macro (raw-list)
                                (let ((inner-cond (macro (cond-list-sym)
                                                         (let ((cond-list (eval cond-list-sym)))
                                                            (let ((first-cond (first cond-list))
                                                                  (rest-cond (rest cond-list)))
                                                                  (let ((first-pred (first first-cond))
                                                                        (first-result (first (rest first-cond))))
                                                                        (if (eval first-pred)
                                                                            first-result
                                                                            (if (nil? rest-cond)
                                                                                ()
                                                                                (inner-cond rest-cond))))))))
                                      (list-sym raw-list))
                                      (inner-cond list-sym)))))))))
