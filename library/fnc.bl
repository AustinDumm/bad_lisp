(let* ((reverse (lambda (list)
            (((lambda (x) (x x))
             (lambda (reverse*)
                (lambda (list running)
                        (if (nil? list)
                            running
                            ((reverse* reverse*) (rest list) (cons (first list) running)))))) list ())))
       (count (lambda (data)
                (((lambda (x) (x x))
                    (lambda (count*)
                        (lambda (data running)
                            (if (nil? data)
                                running
                                ((count* count*) (rest data) (+ 1 running)))))) data 0)))
       (map (lambda (values func)
                (((lambda (x) (x x))
                    (lambda (map*)
                        (lambda (values func running)
                            (if (nil? values)
                                (reverse running)
                                ((map* map*) (rest values) func (cons (func (first values)) running)))))) values func ())))
       (reduce ((lambda (x) (x x))
                    (lambda (reduce*)
                        (lambda (values func acc)
                            (if (nil? values)
                                acc
                                ((reduce* reduce*) (rest values) func (func (first values) acc)))))))
       (filter (lambda (values predicate)
                    (((lambda (x) (x x))
                        (lambda (filter*)
                            (lambda (values predicate running)
                                (if (nil? values)
                                    (reverse running)
                                    (if (predicate (first values))
                                        ((filter* filter*) (rest values) predicate (cons (first values) running))
                                        ((filter* filter*) (rest values) predicate running)))))) values predicate ())))
       (range (lambda (first last step)
                            (((lambda (x) (x x))
                                (lambda (range*)
                                    (lambda (first last step running)
                                        (if (> (* first (sign step)) (* last (sign step)))
                                            (reverse running)
                                            ((range* range*) (+ first step) last step (cons first running)))))) first last step ())))
       (all-satisfy ((lambda (x) (x x))
                        (lambda (all-satisfy*)
                            (lambda (data predicate)
                                (if (nil? data)
                                    #t
                                    (if (not (predicate (first data)))
                                        #f
                                        ((all-satisfy* all-satisfy*) (rest data) predicate)))))))
       (any-satisfy (lambda (data predicate)
                        (not (all-satisfy data (lambda (x) (not (predicate x)))))))
       (first-satisfying ((lambda (x) (x x))
                            (lambda (first-sat*)
                                (lambda (data predicate)
                                    (if (nil? data)
                                        ()
                                        (if (predicate (first data))
                                            (first data)
                                            ((first-sat* first-sat*) (rest data) predicate)))))))
       (zip (lambda (left right)
                (((lambda (x) (x x))
                      (lambda (zip*)
                            (lambda (left right running)
                                (if (or (nil? left) (nil? right))
                                    (reverse running)
                                    ((zip* zip*) (rest left) (rest right) (cons (list (first left) (first right)) running)))))) left right ())))
       (take (lambda (list count)
                (((lambda (x) (x x))
                    (lambda (take*)
                        (lambda (list count running)
                            (if (or (= count 0) (nil? list))
                                (reverse running)
                                ((take* take*) (rest list) (- count 1) (cons (first list) running)))))) list count ())))
       (drop ((lambda (x) (x x))
                (lambda (drop*)
                    (lambda (list count)
                        (if (or (= count 0) (nil? list))
                            list
                            ((drop* drop*) (rest list) (- count 1)))))))
       (pick ((lambda (x) (x x))
                (lambda (pick*)
                    (lambda (elt list)
                        (if (nil? list)
                            ()
                            (if (= elt 0)
                                (first list)
                                ((pick* pick*) (- elt 1) (rest list))))))))
       (append (lambda (start end)
                    (((lambda (x) (x x))
                        (lambda (append*)
                            (lambda (start end)
                                (if (nil? start)
                                    end
                                    ((append* append*) (rest start) (cons (first start) end)))))) (reverse start) end))))
       `((reverse ,reverse)
         (count ,count)
         (map ,map)
         (reduce ,reduce)
         (filter ,filter)
         (range ,range)
         (all-satisfy ,all-satisfy)
         (any-satisfy ,any-satisfy)
         (first-satisfying ,first-satisfying)
         (zip ,zip)
         (take ,take)
         (drop ,drop)
         (pick ,pick)
         (append ,append)))
