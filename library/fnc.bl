(quote  ((reverse (lambda (list)
            (((lambda (x) (x x))
             (lambda (reverse*)
                (lambda (list running)
                        (if (nil? list)
                            running
                            ((reverse* reverse*) (rest list) (cons (first list) running)))))) list ())))
        (map (lambda (func values)
                (((lambda (x) (x x))
                    (lambda (map*)
                        (lambda (func values running)
                            (if (nil? values)
                                (reverse running)
                                ((map* map*) func (rest values) (cons (func (first values)) running)))))) func values ())))
        (reduce ((lambda (x) (x x))
                        (lambda (reduce*)
                            (lambda (values acc func)
                                (if (nil? (rest values))
                                    (func acc (first values))
                                    (func ((reduce* reduce*) (rest values) acc func) (first values)))))))
        (filter ((lambda (x) (x x))
                        (lambda (filter*)
                            (lambda (values predicate)
                                (if (nil? values)
                                    ()
                                    (if (predicate (first values))
                                        (cons (first values) ((filter* filter*) (rest values) predicate))
                                        ((filter* filter*) (rest values) predicate)))))))
        (range ((lambda (x) (x x))
                       (lambda (range*)
                            (lambda (first last step)
                                (if (> (* first (sign step)) (* last (sign step)))
                                    ()
                                    (cons first ((range* range*) (+ first step) last step)))))))
        (range (lambda (first last step)
                    (((lambda (x) (x x))
                        (lambda (range*)
                            (lambda (first last step running)
                                (if (> (* first (sign step)) (* last (sign step)))
                                    (reverse running)
                                    ((range* range*) (+ first step) last step (cons first running)))))) first last step ())))
        (cond (macro (raw-list)
                        (let ((inner-cond (macro (cond-list-sym)
                                                 (let ((cond-list (eval cond-list-sym)))
                                                    (let ((first-cond (first cond-list))
                                                          (rest-cond (rest cond-list)))
                                                          (let ((first-pred (first first-cond))
                                                                (first-result (first (rest first-cond))))
                                                                (if (eval first-pred)
                                                                    first-result
                                                                    (if (nil? rest-cond)
                                                                        ()
                                                                        (inner-cond rest-cond))))))))
                              (list-sym raw-list))
                              (inner-cond list-sym)))))))
